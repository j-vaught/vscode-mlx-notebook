import * as vscode from 'vscode';
import { parseMlx } from './parser';
import { formatOutputs } from './outputParser';
import { buildDocumentXml } from './documentBuilder';
import { buildOutputXml, CellOutputData } from './outputBuilder';
import JSZip from 'jszip';

const zipCache = new Map<string, JSZip>();

export class MlxNotebookSerializer implements vscode.NotebookSerializer {
  async deserializeNotebook(
    content: Uint8Array,
    _token: vscode.CancellationToken
  ): Promise<vscode.NotebookData> {
    const { cells, zip } = await parseMlx(content);

    const cellData: vscode.NotebookCellData[] = cells.map(cell => {
      if (cell.kind === 'code') {
        const cellObj = new vscode.NotebookCellData(
          vscode.NotebookCellKind.Code,
          cell.content,
          'matlab'
        );

        if (cell.outputs && cell.outputs.length > 0) {
          const text = formatOutputs(cell.outputs);
          cellObj.outputs = [
            new vscode.NotebookCellOutput([
              vscode.NotebookCellOutputItem.json(
                { outputs: cell.outputs, source: 'cached' },
                'application/mlx-output+json'
              ),
              vscode.NotebookCellOutputItem.text(text, 'text/plain'),
            ]),
          ];
        }

        return cellObj;
      }

      return new vscode.NotebookCellData(
        vscode.NotebookCellKind.Markup,
        cell.content,
        'markdown'
      );
    });

    const notebook = new vscode.NotebookData(cellData);
    // Generate a stable key from content hash
    const key = hashContent(content);
    zipCache.set(key, zip);
    notebook.metadata = { zipCacheKey: key };
    return notebook;
  }

  async serializeNotebook(
    data: vscode.NotebookData,
    _token: vscode.CancellationToken
  ): Promise<Uint8Array> {
    const key = data.metadata?.zipCacheKey as string | undefined;
    const originalZip = key ? zipCache.get(key) : undefined;

    // Build cell data from notebook
    const cells: Array<{ kind: 'code' | 'markup'; content: string; executionOutputs?: CellOutputData }> = [];
    for (const cell of data.cells) {
      const kind = cell.kind === vscode.NotebookCellKind.Code ? 'code' : 'markup';
      const entry: typeof cells[0] = { kind, content: cell.value };

      // Extract outputs from code cells
      if (kind === 'code' && cell.outputs && cell.outputs.length > 0) {
        for (const output of cell.outputs) {
          for (const item of output.items) {
            if (item.mime === 'application/mlx-output+json') {
              try {
                const parsed = JSON.parse(new TextDecoder().decode(item.data));
                if (parsed.outputs) {
                  entry.executionOutputs = {
                    outputs: parsed.outputs,
                    figures: parsed.figures,
                    text: parsed.text,
                  };
                }
              } catch {
                // ignore parse errors
              }
            }
          }
        }
      }

      cells.push(entry);
    }

    // Generate new document.xml and output.xml
    const docXml = buildDocumentXml(cells);
    const outXml = buildOutputXml(cells);

    // Clone original zip or create new one
    let zip: JSZip;
    if (originalZip) {
      // Clone by re-loading from generated bytes
      const originalBytes = await originalZip.generateAsync({ type: 'uint8array' });
      zip = await JSZip.loadAsync(originalBytes);
    } else {
      zip = new JSZip();
      zip.folder('matlab');
    }

    // Replace document and output XML, preserve everything else
    zip.file('matlab/document.xml', docXml);
    zip.file('matlab/output.xml', outXml);

    const result = await zip.generateAsync({
      type: 'uint8array',
      compression: 'DEFLATE',
      compressionOptions: { level: 6 },
    });

    // Update cache with new zip
    if (key) {
      zipCache.set(key, await JSZip.loadAsync(result));
    }

    return result;
  }
}

function hashContent(content: Uint8Array): string {
  // Simple hash for cache key
  let hash = 0;
  for (let i = 0; i < content.length; i += 64) {
    hash = ((hash << 5) - hash + content[i]) | 0;
  }
  return `mlx_${hash}_${content.length}`;
}
